local fps = 60
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
 if not c then
  con:Disconnect()
  return
 end
    --tf += s
 if tf >= fps then
  for i=1, floor(tf / fps) do
   event:Fire(c)
  end
  tf = 0
 end
end)
local event = event.Event

--local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end


omgHuman = game.Players.LocalPlayer.Character.HumanoidRootPart
UselessPartLmao = Instance.new("Part", omgHuman)
UselessPartLmao.Name = "life fucking sucks and i wanna jump off a bridge"
UselessPartLmao.CanCollide = false
UselessPartLmao.Transparency = 1


local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

for i,v in pairs (cplayer:GetChildren()) do
 if v:IsA("Accessory") then
  v.Handle.Massless = true
  v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
 end
end

 game.Players.LocalPlayer.Character.Head.Anchored = false

plr = game.Players.LocalPlayer 
char = plr.Character
 
local lp = game:GetService("Players").LocalPlayer
local cplayer = lp.Character
local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
Plr = plr
plr.Character.Animate:Destroy()
local char = Plr.Character

local BBoard = Instance.new("BillboardGui", char.Head)
BBoard.Adornee = char.Head
BBoard.StudsOffset = Vector3.new(-6, 4, 0)
BBoard.Size = UDim2.new(4,0,2,0)

local ModeName = Instance.new("TextLabel", BBoard)
ModeName.Text = "Studio Dummy V1"
ModeName.BackgroundTransparency = 1
ModeName.TextScaled = true
ModeName.TextStrokeTransparency = 0
ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
ModeName.Size = BBoard.Size
 --ModeName.F
ModeName.TextColor3 = Color3.fromRGB(0,0,0)

local omgitskorn =  Instance.new("Highlight")  
omgitskorn.Parent = char
omgitskorn.FillColor = Color3.fromRGB(0,0,0)
omgitskorn.FillTransparency = 1
omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)

local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)

cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
Mode = 1
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 


RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors

LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
 tf = tf + s
 if tf >= frame then
  if allowframeloss then
   script.Heartbeat:Fire()
   lastframe = tick()
  else
   for i = 1, math.floor(tf / frame) do
    script.Heartbeat:Fire()
   end
   lastframe = tick()
  end
  if tossremainder then
   tf = 0
  else
   tf = tf - frame * math.floor(tf / frame)
  end
 end
end)

function swait(num)
 if num == 0 or num == nil then
  game:service("RunService").Stepped:wait(0)
 else
  for i = 0, num do
   game:service("RunService").Stepped:wait(0)
  end
 end
end
function thread(f)
 coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
 local qa = {
  QuaternionFromCFrame(a)
 }
 local qb = {
  QuaternionFromCFrame(b)
 }
 local ax, ay, az = a.x, a.y, a.z
 local bx, by, bz = b.x, b.y, b.z
 local _t = 1 - t
 return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
 local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
 local trace = m00 + m11 + m22
 if trace > 0 then
  local s = math.sqrt(1 + trace)
  local recip = 0.5 / s
  return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
 else
  local i = 0
  if m00 < m11 then
   i = 1
  end
  if m22 > (i == 0 and m00 or m11) then
   i = 2
  end
  if i == 0 then
   local s = math.sqrt(m00 - m11 - m22 + 1)
   local recip = 0.5 / s
   return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
  elseif i == 1 then
   local s = math.sqrt(m11 - m22 - m00 + 1)
   local recip = 0.5 / s
   return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
  elseif i == 2 then
   local s = math.sqrt(m22 - m00 - m11 + 1)
   local recip = 0.5 / s
   return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
  end
 end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
 local xs, ys, zs = x + x, y + y, z + z
 local wx, wy, wz = w * xs, w * ys, w * zs
 local xx = x * xs
 local xy = x * ys
 local xz = x * zs
 local yy = y * ys
 local yz = y * zs
 local zz = z * zs
 return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
 local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
 local startInterp, finishInterp
 if cosTheta >= 1.0E-4 then
  if 1 - cosTheta > 1.0E-4 then
   local theta = math.acos(cosTheta)
   local invSinTheta = 1 / Sin(theta)
   startInterp = Sin((1 - t) * theta) * invSinTheta
   finishInterp = Sin(t * theta) * invSinTheta
  else
   startInterp = 1 - t
   finishInterp = t
  end
 elseif 1 + cosTheta > 1.0E-4 then
  local theta = math.acos(-cosTheta)
  local invSinTheta = 1 / Sin(theta)
  startInterp = Sin((t - 1) * theta) * invSinTheta
  finishInterp = Sin(t * theta) * invSinTheta
 else
  startInterp = t - 1
  finishInterp = t
 end
 return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
 return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end

function FaceMouse()
local Cam = workspace.CurrentCamera
 return {
  CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
  Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
 }
end

local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end

local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ

hum.WalkSpeed = 8
hum.JumpPower = 57

local ANIMATOR = hum.Animator
ANIMATOR.Parent = nil


local hat2 = gp(cplayer, "PogoStick", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0, 0, 1) --LavanderHair
att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair

plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
mouse.KeyDown:connect(function(Key)
if Key == "m" and attack==false and Mode == 1 then
  Mode = 2
  ModeName.Text = "Studio Dummy V2"
        att2.Parent = cplayer["Right Arm"]
        att2.Position = Vector3.new(-0.5, -3, -0.3)
        att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
 elseif Key == "m" and Mode == 2 then
  Mode = 3
  ModeName.Text = "Studio Dummy V3"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
        att2.Parent = cplayer["Torso"]
        att2.Position = Vector3.new(0, 0, 1) --LavanderHair
        att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair
 elseif Key == "m" and Mode == 3 then
  Mode = 1
  ModeName.Text = "Studio Dummy V1"
        att2.Parent = cplayer["Torso"]
        att2.Position = Vector3.new(0, 0, 1) --LavanderHair
        att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair
 end
end)

while true do
   swait()
 sine = sine + change
 local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
 local velderp = root.Velocity.y
 hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
  if 1 < root.Velocity.y and hitfloor == nil then
   Anim = "Jump"
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(90 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 2 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(-45), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(-0), Rad(-0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(-20 - 0 * Sin(sine / 12)), Rad(50)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.35* Player_Size, 0.55 + 0.1 * Sin(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(-90), Rad(0 + 0 * Sin(sine / 12)), Rad(-90 + 15 * Sin(sine / 15.5))), 0.1)
    VA.C0 = clerp(VA.C0, CF(0* Player_Size, -0 + 0 * Sin(sine / 12)* Player_Size, 2* Player_Size) * angles(Rad(-0), Rad(0 - -0 * Sin (sine / 12)), Rad(90 - -90 * Sin(sine / 12))), 0.1)
   elseif attack == false and Mode == 3 then
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(-45), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(-0), Rad(-0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(6 - 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(6 + 6.5 * Sin(sine / 12)), Rad(90)), 0.1)
    VA.C0 = clerp(VA.C0, CF(0* Player_Size, -0 + 0 * Sin(sine / 12)* Player_Size, 2* Player_Size) * angles(Rad(-0), Rad(0 - -0 * Sin (sine / 12)), Rad(0 - -0 * Sin(sine / 12))), 0.1)
   end
         
  elseif -1 > root.Velocity.y and hitfloor == nil then
   Anim = "Fall"
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 2 then
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(45), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(-0), Rad(-0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(-20 - 0 * Sin(sine / 12)), Rad(50)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.35* Player_Size, 0.55 + 0.1 * Sin(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(-90), Rad(0 + 0 * Sin(sine / 12)), Rad(-90 + 15 * Sin(sine / 15.5))), 0.1)
    VA.C0 = clerp(VA.C0, CF(0* Player_Size, -0 + 0 * Sin(sine / 12)* Player_Size, 2* Player_Size) * angles(Rad(-0), Rad(0 - -0 * Sin (sine / 12)), Rad(90 - -90 * Sin(sine / 12))), 0.1)
   elseif attack == false and Mode == 3 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(45), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(-0), Rad(-0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(6 - 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(6 + 6.5 * Sin(sine / 12)), Rad(90)), 0.1)
    VA.C0 = clerp(VA.C0, CF(0* Player_Size, -0 + 0 * Sin(sine / 12)* Player_Size, 2* Player_Size) * angles(Rad(-0), Rad(0 - -0 * Sin (sine / 12)), Rad(0 - -0 * Sin(sine / 12))), 0.1)end
     
  elseif torvel < 1 and hitfloor ~= nil then
   Anim = "Idle"
   change = 1
   if attack == false and Mode == 1 then  
   change  = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(-35), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(-15), Rad(-15)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, -0* Player_Size) * angles(Rad(100), Rad(6 - 6.5 * Sin(sine / 12)), Rad(-80)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(6 + 6.5 * Sin(sine / 12)), Rad(50)), 0.1)
    VA.C0 = clerp(VA.C0, CF(-1* Player_Size, -0 + 0 * Sin(sine / 12)* Player_Size, 2* Player_Size) * angles(Rad(-0), Rad(0 - -0 * Sin (sine / 12)), Rad(0 - -0 * Sin(sine / 12))), 0.1)
   elseif attack == false and Mode == 2 then
   change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, -1 + 0.5 * Sin(sine / 15.5)* Player_Size, 0.55 + 0.2* Player_Size * Cos(sine / 7)) * angles(Rad(-35 + 10 * Sin(sine / 15.5)), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), Rad(0)), 0.1) 
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-0), Rad(-15), Rad(-10 + -15 * Sin(sine / 15.5))), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1 - 0.1 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(-9 + 15 * Sin(sine / 15.5)), Rad(25 + -15 * Sin(sine / 15.5)), Rad(25 + 15 * Sin(sine / 15.5))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(-20 - 0 * Sin(sine / 12)), Rad(50)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.35* Player_Size, 0.55 + 0.1 * Sin(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(-90), Rad(0 + 0 * Sin(sine / 12)), Rad(-90 + 15 * Sin(sine / 15.5))), 0.1)
    VA.C0 = clerp(VA.C0, CF(-0* Player_Size, -0 + 0 * Sin(sine / 12)* Player_Size, 2* Player_Size) * angles(Rad(-0), Rad(0 - -0 * Sin (sine / 12)), Rad(0 - -0 * Sin(sine / 12))), 0.1)
   elseif attack == false and Mode == 3 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0 + 0.05 * Player_Size * Cos(sine / 12)) * angles(Rad(-0), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / 45)), Rad(-15), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0 * Cos(sine / 12)* Player_Size, 0.4* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-0), Rad(0), Rad(-0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1 - 0 * Cos(sine / 12)* Player_Size, -0.4* Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(-0), Rad(0), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, -0* Player_Size) * angles(Rad(25), Rad(0 - 0 * Sin(sine / 12)), Rad(15)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-10), Rad(0 + 0 * Sin(sine / 12)), Rad(0)), 0.1)
    VA.C0 = clerp(VA.C0, CF(-1* Player_Size, 1 + 0.3 * Sin(sine / 50)* Player_Size, -3* Player_Size) * angles(Rad(30), Rad(10 - -20 * Sin (sine / 100)), Rad(0 - -1 * Sin(sine / 12))), 0.1)
   end
   
  elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
   Anim = "Walk"
   if attack == false and Mode == 1 then
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(35), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 * Sin(sine / -10)), Rad(0), Rad(-20)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 100)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 100)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(6 - 6.5 * Sin(sine / 12)), Rad(90)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-60), Rad(0 + 0 * Sin(sine / 12)), Rad(-15)), 0.1)
    VA.C0 = clerp(VA.C0, CF(-0* Player_Size, 0 + 0.2 * Sin(sine / 12)* Player_Size, 1* Player_Size) * angles(Rad(0), Rad(0 - 0 * Sin(sine / 12)), Rad(0)), 0.1)
   elseif attack == false and Mode == 2 then
               change = 1
     rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.5 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(35), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-90), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
                LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(-20 - 0 * Sin(sine / 12)), Rad(50)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.35* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(-90), Rad(0 + 0 * Sin(sine / 12)), Rad(-90)), 0.1)
    VA.C0 = clerp(VA.C0, CF(-0* Player_Size, -3 + -0.3 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(-90), Rad(0 - -0 * Sin (sine / 12)), Rad(0 - -0 * Sin(sine / 12))), 0.1)
   elseif attack == false and Mode == 3 then
               rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2.5, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)  
     RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(120)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-120)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
    VA.C0 = clerp(VA.C0, CF(-1* Player_Size, 1 + 0.3 * Sin(sine / 50)* Player_Size, -3* Player_Size) * angles(Rad(30), Rad(10 - -20 * Sin (sine / 100)), Rad(0 - -1 * Sin(sine / 12))), 0.1)
   end
   
  elseif torvel >= 22 and hitfloor ~= nil then
   Anim = "Sprint"
    change = 1.35
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.5* Player_Size * Cos(sine / 12)) * angles(Rad(35), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 * Sin(sine / -10)), Rad(0), Rad(-20)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 100)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 100)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.1 * Sin(sine / 50)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(6 - 6.5 * Sin(sine / 12)), Rad(90)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-60), Rad(0 + 0 * Sin(sine / 12)), Rad(-15)), 0.1)
    VA.C0 = clerp(VA.C0, CF(-0* Player_Size, 0 + 0.2 * Sin(sine / 12)* Player_Size, 1* Player_Size) * angles(Rad(0), Rad(0 - 0 * Sin(sine / 12)), Rad(0)), 0.1)
   elseif attack == false and Mode == 2 then
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.5 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(35), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, 0.3* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(-45)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 50)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(-90), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(35)), 0.1)
                LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(90), Rad(-20 - 0 * Sin(sine / 12)), Rad(50)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.35* Player_Size, 0.5 + 0.1 * Sin(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(-90), Rad(0 + 0 * Sin(sine / 12)), Rad(-90)), 0.1)
    VA.C0 = clerp(VA.C0, CF(-0* Player_Size, -3 + -0.3 * Sin(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(-90), Rad(0 - -0 * Sin (sine / 12)), Rad(0 - -0 * Sin(sine / 12))), 0.1)
   elseif attack == false and Mode == 3 then
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(3) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-10) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
   end
          end
       end
